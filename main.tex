\documentclass[a4paper,12pt]{article}
\usepackage{graphicx}
\usepackage[lmargin=3cm,tmargin=3cm,rmargin=2cm,bmargin=2cm]{geometry}
\usepackage{fancyvrb}
\usepackage{microtype} % Para melhorar a justificação
\usepackage{hyperref} % Pacote para links clicáveis
\begin{document}


\begin{center}
\includegraphics[width=5cm]{saoJudas.png}

\Large \textbf{UNIVERSIDADE SÃO JUDAS TADEU }


\vspace{7.5cm}

\textbf{TEORIA DE COMPILAÇÃO E COMPILADORES}

\vspace{6.5cm}

    \textbf{Caio Bonato \\ Gabriel Castro \\Laysla Rodrigues  \\ 
    Leonardo Freitas \\ Lucas Quireza }\\


\newpage

\newpage

\thispagestyle{empty}
\begin{center}
    \vspace*{1cm}
    \textbf{UNIVERSIDADE SÃO JUDAS TADEU}\\
    \vspace*{1cm}
    \Huge
    \textbf{Compilador de Linguagem}

    \vspace*{8cm}

\LARGE
\begin{flushright}
     \textbf{Professor Anacé Nunes da Silva}
     \end{flushright}

    

    
    
    \vspace{0.5cm}
    \LARGE
    
    
    \vfill





    
    \vfill
    \center
    \Large
    São Paulo, 17 de Junho de 2024 
    
    \end{center}
    
\newpage



\end{center}
\newpage

\renewcommand{\contentsname}{Sumário}
\tableofcontents

\newpage

\section{Resumo}

Este documento explora a implementação de um compilador utilizando a 
biblioteca PLY (Python Lex-Yacc) em Python. O objetivo é criar um 
compilador utilizando o analisador léxico, sintático e semântico para 
uma linguagem específica, utilizando expressões regulares e regras de 
parsing para processar código-fonte em um formato personalizado.\\

\subsection{Abstract}

This document explores the implementation of a compiler using the PLY 
(Python Lex-Yacc) library in Python. The goal is to create a compiler 
utilizing lexical, syntactic, and semantic analysis for a specific 
language. It employs regular expressions and parsing rules to process 
code in a customized format.\\

\section{Conceito de um compilador}
Tradutor de um código escrito em uma linguagem de programação de alto nível para código de máquina específico a uma arquitetura de computador. O compilador realiza várias etapas fundamentais, através da análise léxica, sintática e semântica. E também pode incluir funcionalidades como relatórios de erros, suporte a bibliotecas padrão e integração com ferramentas de desenvolvimento. Em resumo, facilita a transformação de código legível por humanos em instruções que um computador pode executar eficientemente. 

\section{Biblioteca Ply} 


\begin{BVerbatim}
    import ply.lex as lex
    import ply.yacc as yacc    
\end{BVerbatim}
\\


Foi importada e utilizada a biblioteca PLY, para auxiliar na construção 
do compilador, por ser bastante intuitiva.\\

A biblioteca PLY (Python Lex-Yacc) é uma implementação em Python das 
ferramentas tradicionais Lex e Yacc, usadas para análise léxica e 
sintática de linguagens. PLY é útil para criar analisadores de linguagem 
personalizados e é composta por dois módulos principais: lex para a 
análise léxica e yacc para a análise sintática.

\subsection{Como instalar o ply}
\begin{verbatim}
    pip install ply
\end{verbatim}
Para instalar o ply, é preciso colocar o código acima no prompt de comando (cmd) ou no terminal de um compilador de sua escolha, porém para isso você precisa ter instalado tanto o Python quanto o pip para poder instalar a biblioteca ply. 

Se quiser verificar se possui o pip instalado é possível utilizar o código a seguir no prompt de comando para verificar: 

\begin{verbatim}
    pip --version
\end{verbatim}

Para verificar se o ply também foi instalado, basta utilizar o código e encontra-lo na lista(caso possua mais de uma biblioteca): 
\begin{verbatim}
    pip list
\end{verbatim}

\section{Arquivos Do Código Padrão}
Todos os arquivos de código padrão devem ser executados na mesma pasta de um compilador para garantir que não haja nenhum erro na geração de todos os arquivos necessários, que serão citados mais a frente no documento. 

\subsection{Arquivo compialdorA3V2}
Neste arquivo contém todo o codigo do compilador : Analise Lexica, 
Sintatica, Semantica, todas as definiçoes dos tokens da nossa linguagem 
e as declarações do que cada uma faz e nas proximas partes estaram 
explicados o que cada parte.

\subsection{Codigo\_input.txt}
Este compilador utiliza um arquivo chamado codigo\_input.txt que contém 
o código-fonte de exemplo que será utilizado para a compilação da 
linguagem para Python.

\section{Análise Léxica}
Na análise léxica serão efetuadas as seguintes tarefas: definição de 
tokens, expressões regulares para tokens, funções de tratamento para 
tokens, ignorar espaços e caracteres irrelevantes, tratamento de erros e 
a inicialização do lexer.


\subsection{Definição de Tokens}

\begin{BVerbatim}
    tokens = [
INPROGRAMA: inprograma
FMPROGRAMA: fmprograma
NI: ni
VARIAVEL: Identificador (nomes de variáveis)
INTEIRO: Números inteiros
FLOAT: Números de ponto flutuante
OP_ATRIB_IGUAL: =
OP_FINAL_LINHA_PONTO_VIRGULA: ;
PARA: para
LEIA: leia
ESCREVA: escreva
ENQUANTO: enquanto
LESS: <
GREATER: >
OP_PAR_ESQUERDO: (
OP_PAR_DIREITO: )
OP_CHAVE_ESQUERDA: {
OP_CHAVE_DIREITA: }
OP_SOMA: +
IN: in
RANGE: range
\end{BVerbatim}
\\


Os tokens em um compilador são elementos léxicos, ou seja, as menores 
unidades de significado no código-fonte que possuem um significado 
específico. São gerados durante a fase de análise léxica.


\subsection{Expressões regulares para tokens}

\begin{Verbatim}

# Regras de expressão regular para tokens
t_INPROGRAMA = r'inprograma'
t_FMPROGRAMA = r'fmprograma'
t_NI = r'ni'
t_OP_ATRIB_IGUAL = r'='
t_OP_FINAL_LINHA_PONTO_VIRGULA = r';'
t_PARA = r'para'
t_LEIA = r'leia'
t_ESCREVA = r'escreva'
t_ENQUANTO = r'enquanto'
t_LESS = r'<'
t_GREATER = r'>'
t_OP_PAR_ESQUERDO = r'\('
t_OP_PAR_DIREITO = r'\)'
t_OP_CHAVE_ESQUERDA = r'\{'
t_OP_CHAVE_DIREITA = r'\}'
t_OP_SOMA = r'\+'
t_IN = r'in'
t_RANGE = r'range'
\end{Verbatim}

O token é definido por uma expressão regular (regex), que especifica 
como os caracteres do código-fonte correspondem a cada um.

\subsection{Funções de tratamento para tokens}

\begin{Verbatim}
#Converte o valor do token para um número de ponto flutuante.
    def t_FLOAT(t): 
    r'\d+\.\d+'
    t.value = float(t.value)
    return t
    
#Converte o valor do token para um número inteiro
def t_INTEIRO(t): .V
    r'\d+'
    t.value = int(t.value)
    return t

def t_VARIAVEL(t): 
#Verifica se o identificador é uma palavra-chave reservada 
(como ni, inprograma, etc.) e, se for, ajusta o tipo do token.
    r'[a-zA-Z_][a-zA-Z_0-9]*'
    if t.value in {'ni', 'inprograma', 'fmprograma', 'escreva', 'leia', 
    'para', 
    'enquanto', 'in', 'range'}:
        t.type = t.value.upper()  
        
        # Transforma em maiúsculas para tratar como palavra-chave
    return t
    
\end{Verbatim}

\subsection{Ignorar espaços e caracteres irrelevantes}

\begin{verbatim}
    t_ignore = ' \t\n'
\end{verbatim}

A variável t ignore é utilizada para ignorar espaços, tabulações e novas 
linhas durante a tokenização.

\subsection{Tratamento de erros}
\begin{verbatim}
    def t_error(t):
    print("Caractere ilegal '%s'" % t.value[0])
    t.lexer.skip(1)

\end{verbatim}
A função t error(t) ocorre quando um caractere ilegal é encontrado no 
código-fonte.

\subsection{inicialização do lexer e finalização da análise léxica}
\begin{verbatim}
    lexer = lex.lex()
\end{verbatim}
Análisa se todas as partes que foram citadas está coerente.

\subsection{Conjunto de Variáveis Declaradas e Lista de Erros}
\begin{verbatim}
    variaveis_declaradas = set()
erros = []
\end{verbatim}
Inicializa um conjunto para armazenar as variáveis declaradas e uma 
lista para registrar os erros encontrados durante a análise léxica; caso 
haja falhas, será apontado em qual linha o problema se localiza.

\section{Início da análise sintética e semântica}

\subsection{Regras de parsing}
Nos tópicos a seguir, há definições sobre as funções que foram 
utilizadas com a biblioteca PLY para construir a gramática da linguagem, 
todas são prefixadas por p\_

\subsection{p\_Programa}
\begin{verbatim}
    def p_programa(p):
    '''
    programa : INPROGRAMA declaracoes FMPROGRAMA
    '''
    p[0] = p[2]
\end{verbatim}
Esta regra define a estrutura básica de um programa. Deve começar com 
INPROGRAMA, seguido por uma série de declarações (declaracoes) e 
terminar com FMPROGRAMA.\\

p[0] armazena o resultado final das declarações.

\subsection{p\_Declaracoes\_Single e p\_Declaracoes\_Mult}
\begin{verbatim}
    def p_declaracoes_single(p):
    '''
    declaracoes : declaracao
    '''
    p[0] = p[1]

def p_declaracoes_mult(p):
    '''
    declaracoes : declaracoes declaracao
    '''
    p[0] = p[1] + p[2]
\end{verbatim}
p\_Declaracoes\_Single lida com uma única declaraçãos.\\
p\_Declaracoes\_Mult lida com múltiplas declarações, concatenando-as.

\subsection{p\_Declaracao\_Ni\_atribuicao}
\begin{verbatim}
    def p_declaracao_ni_atribuicao(p):
    '''
    declaracao : NI VARIAVEL OP_ATRIB_IGUAL expressao 
    
    OP_FINAL_LINHA_PONTO_VIRGULA
    '''
    variavel = p[2]
    if variavel in variaveis_declaradas:
        erro = f"Erro: Variável '{variavel}' já foi declarada."
        print(erro)
        erros.append(erro)
        p[0] = ""
    else:
        variaveis_declaradas.add(variavel)
        p[0] = f"{variavel} = {p[4]}\n"
\end{verbatim}
Define uma declaração de variável com atribuição (usando NI).\\
Verifica se a variável já foi declarada. Se sim, adiciona um erro.\\
Caso contrário, adiciona a variável ao conjunto de variáveis declaradas.

\subsection{p\_Declaracao\_Atribuicao}
\begin{verbatim}
    def p_declaracao_atribuicao(p):
    '''
    declaracao : VARIAVEL OP_ATRIB_IGUAL expressao 
    
    OP_FINAL_LINHA_PONTO_VIRGULA
    '''
    variavel = p[1]
    if variavel not in variaveis_declaradas:
        erro = f"Erro: Variável '{variavel}' não foi declarada antes de 
        usar."
        print(erro)
        erros.append(erro)
        p[0] = ""
    else:
        p[0] = f"{variavel} = {p[3]}\n"
\end{verbatim}
Define uma atribuição de valor a uma variável.\\
Verifica se a variável foi declarada. Se não, adiciona um erro.

\subsection{p\_Declaracao\_Escreva}
\begin{verbatim}
    def p_declaracao_escreva(p):
    '''
    declaracao : ESCREVA expressao OP_FINAL_LINHA_PONTO_VIRGULA
    '''
    p[0] = f"print({p[2]})\n"
\end{verbatim}
Define uma declaração ESCREVA que imprime o valor de uma expressão.

\subsection{p\_Declaracao\_Leia}
\begin{verbatim}
    def p_declaracao_leia(p):
    '''
    declaracao : LEIA VARIAVEL OP_FINAL_LINHA_PONTO_VIRGULA
    '''
    variavel = p[2]
    if variavel not in variaveis_declaradas:
        variaveis_declaradas.add(variavel)
    p[0] = f"{variavel} = float(input('Digite um numero : '))\n"
\end{verbatim}
Define uma declaração LEIA, que consulta um valor do usuário e o 
armazena em uma variável.\\
Se a variável ainda não foi declarada, é adicionada ao conjunto de 
variáveis declaradas.

\subsection{p\_Declaracao\_Para}

\begin{verbatim}
    def p_declaracao_para(p):
    '''
    declaracao : PARA OP_PAR_ESQUERDO VARIAVEL IN RANGE OP_PAR_ESQUERDO 
    
    expressao OP_PAR_DIREITO OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA
    '''
    variavel = p[3]
    variaveis_declaradas.add(variavel)  
    # Implicitamente declarando a variável do loop
    p[0] = f"for {variavel} in range({p[7]}):\n{indent(p[11], 4)}\n"
\end{verbatim}

Define um loop PARA (equivalente a um loop for).\\
Adiciona a variável do loop ao conjunto de variáveis declaradas 

implicitamente.

\subsection{p\_Declaracao\_Enquanto}

\begin{verbatim}
    def p_declaracao_enquanto(p):
    '''
    declaracao : 
    ENQUANTO OP_PAR_ESQUERDO condicao 
    OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA
    '''
    p[0] = f"while {p[3]}:\n{indent(p[6], 4)}\n"
\end{verbatim}
Define um loop ENQUANTO (equivalente a um loop while).

\subsection{p\_Expressao}
\begin{verbatim}
    def p_expressao(p):
    '''
    expressao : INTEIRO
              | FLOAT
              | VARIAVEL
              | VARIAVEL OP_SOMA expressao
    '''
    if len(p) == 2:
        p[0] = f"{p[1]}"
    else:
        p[0] = f"{p[1]} + {p[3]}"
\end{verbatim}
Define como uma expressão podendo ser um inteiro, um float, uma variável 
ou uma soma de variável com outra expressão.

\subsection{p\_Condicao}
\begin{verbatim}
    def p_condicao(p):
    '''
    condicao : expressao LESS expressao
             | expressao GREATER expressao
    '''
    p[0] = f"{p[1]} {p[2]} {p[3]}"
\end{verbatim}
Define uma condição como uma comparação entre duas expressões usando 
operadores de comparação (< ou >).
\subsection{p\_Error}
\begin{verbatim}
    def p_error(p):
    if p:
        erro = f"Erro de sintaxe em '{p.value}'"
        print(erro)
        erros.append(erro)
    else:
        erro = "Erro de sintaxe no final do arquivo"
        print(erro)
        erros.append(erro)
\end{verbatim}
Define o tratamento de erros sintáticos, imprimindo uma mensagem de erro 
e adicionando-a à lista de erros.

\section{Fim da análise sintática e semantica}
Finalizada a definição de regras de gramatica usando as funcoes que 
comecam com p\_ para definir a estrutura do codigo.

\section{Processamento e Análise de Código Python}

\subsection{Função Auxiliar para Indentação}
\begin{verbatim}
    def indent(text, spaces):
    return '\n'.join(' ' * spaces + line if line else '' 
    for line in text.splitlines())
\end{verbatim}
O intuito desta função é adicionar indentação ao código gerado.


\subsection{Codigo\_Fonte}
    \begin{verbatim}
        with open('codigo_input.txt', 'r') as file:
    linhas = file.readlines()

    codigoFonte = ""

\end{verbatim}   
O arquivo codigo\_input.txt é aberto e incluído numa string vazia 
chamada codigo\_fonte. Esta string será usada para armazenar todo o 
conteúdo do arquivo de entrada em uma única string, removendo caracteres 
de nova linha.

\subsection{Remoção de espaços}
\begin{verbatim}
    for linha in linhas:
    codigo_fonte += linha.strip() + "\n"

\end{verbatim}
A função Strip foi utilizada para remover os espaços em brancos e 
caracteres de nova linha de cada linha e em seguida é concatenado com a 
string codigoFonte acrescentando sempre um caracter 
\texttt{\textbackslash n} ao final de cada linha para manter a 
formatação.

\subsection{Processando o codigo\_Fonte com o analisador léxico}
\begin{verbatim}
    lexer.input(codigo_fonte)
\end{verbatim}
Configurado o analisador léxico (lexer), que processa a string 
codigo\_Fonte. Sendo responsável por dividir a entrada em "tokens" ou 
unidades léxicas, como palavras-chave, identificadores, operadores, etc.

\section{codigo\_input.txt}
O input, ou entrada, em um contexto de análise léxica e sintática, 
refere-se ao código-fonte ou texto que está sendo processado pelo 
compilador ou interpretador. É o conjunto de caracteres ou símbolos que 
compõem o programa de computador que será traduzido ou interpretado.

\begin{verbatim}
inprograma
    ni value = 10;
    leia x;
    leia y;
    para (i in range(value)) {
        escreva i;
    }
    enquanto (x < 20) {
        x = x + 1.5;
        escreva x;
    }
    escreva x + y;
fmprograma
\end{verbatim}

\subsection{Início do Programa:}
    inprograma
  
    - Indica o início do programa.
\\
\subsection{Declaração de Variável:}

\begin{verbatim}
    ni value = 10; 
\end{verbatim}

    - Declara uma variável chamada `value` e a inicializa com o valor 
    `10`.
\\    
\subsection{Leitura de Entrada:}

    leia x;
    \\
    leia y;
    \\
    - Lê dois valores de entrada e os armazena nas variáveis `x` e `y`.
\\
Laço `para`:
 \begin{verbatim}  
    para (i in range(value)) {
        escreva i;
    }
 \end{verbatim}   
    - Um laço `para` que itera de `0` até `value - 1` (ou seja, de 0 a 
    9, porque `value` é 10).
    \\
    - Em cada iteração, imprime o valor de `i`.
    
\subsection{Laço `enquanto`:}
  \begin{verbatim} 
    enquanto (x < 20) {
        x = x + 1.5;
        escreva x;
    }
 \end{verbatim}    
    - Um laço `enquanto` que continua enquanto `x` for menor que `20`.
    \\
    - Dentro do laço, `x` é incrementado em `1.5` a cada iteração e o 
    novo valor de `x` é impresso.
\\    
\subsection{Impressão Final:}
    
    escreva x + y;
    \\
    - Imprime a soma de `x` e `y`.
\subsection{Fim do Programa:}
    
    fmprograma
    \\
    - Indica o fim do programa.

\section{Codigos Gerados apos a compilação do arquivo codigo\_input.txt 
com o  compilador\_a3\_v2.py}

\subsection{Tokens\_output.txt}
Tokens são unidades léxicas básicas em um programa de computador. Eles 
são os blocos de construção fundamentais da análise léxica, que é a 
primeira etapa do processo de compilação. Durante a análise léxica, o 
código-fonte é dividido em tokens para facilitar a análise posterior.\\

Arquivo criado para monitorar a saída dos tokens e suas definições que 
foram geradas após a compilação do arquivo codigo\_Input.txt

\begin{verbatim}
    
Token tipo = INPROGRAMA, valor = inprograma, linha = 1
Token tipo = NI, valor = ni, linha = 1
Token tipo = VARIAVEL, valor = value, linha = 1
Token tipo = OP_ATRIB_IGUAL, valor = =, linha = 1
Token tipo = INTEIRO, valor = 10, linha = 1
Token tipo = OP_FINAL_LINHA_PONTO_VIRGULA, valor = ;, linha = 1
Token tipo = LEIA, valor = leia, linha = 1
Token tipo = VARIAVEL, valor = x, linha = 1
Token tipo = OP_FINAL_LINHA_PONTO_VIRGULA, valor = ;, linha = 1
Token tipo = LEIA, valor = leia, linha = 1
Token tipo = VARIAVEL, valor = y, linha = 1
Token tipo = OP_FINAL_LINHA_PONTO_VIRGULA, valor = ;, linha = 1
Token tipo = PARA, valor = para, linha = 1
Token tipo = OP_PAR_ESQUERDO, valor = (, linha = 1
Token tipo = VARIAVEL, valor = i, linha = 1
Token tipo = IN, valor = in, linha = 1
Token tipo = RANGE, valor = range, linha = 1
Token tipo = OP_PAR_ESQUERDO, valor = (, linha = 1
Token tipo = VARIAVEL, valor = value, linha = 1
Token tipo = OP_PAR_DIREITO, valor = ), linha = 1
Token tipo = OP_PAR_DIREITO, valor = ), linha = 1
Token tipo = OP_CHAVE_ESQUERDA, valor = {, linha = 1
Token tipo = ESCREVA, valor = escreva, linha = 1
Token tipo = VARIAVEL, valor = i, linha = 1
Token tipo = OP_FINAL_LINHA_PONTO_VIRGULA, valor = ;, linha = 1
Token tipo = OP_CHAVE_DIREITA, valor = }, linha = 1
Token tipo = ENQUANTO, valor = enquanto, linha = 1
Token tipo = OP_PAR_ESQUERDO, valor = (, linha = 1
Token tipo = VARIAVEL, valor = x, linha = 1
Token tipo = LESS, valor = <, linha = 1
Token tipo = INTEIRO, valor = 20, linha = 1
Token tipo = OP_PAR_DIREITO, valor = ), linha = 1
Token tipo = OP_CHAVE_ESQUERDA, valor = {, linha = 1
Token tipo = VARIAVEL, valor = x, linha = 1
Token tipo = OP_ATRIB_IGUAL, valor = =, linha = 1
Token tipo = VARIAVEL, valor = x, linha = 1
Token tipo = OP_SOMA, valor = +, linha = 1
Token tipo = FLOAT, valor = 1.5, linha = 1
Token tipo = OP_FINAL_LINHA_PONTO_VIRGULA, valor = ;, linha = 1
Token tipo = ESCREVA, valor = escreva, linha = 1
Token tipo = VARIAVEL, valor = x, linha = 1
Token tipo = OP_FINAL_LINHA_PONTO_VIRGULA, valor = ;, linha = 1
Token tipo = OP_CHAVE_DIREITA, valor = }, linha = 1
Token tipo = ESCREVA, valor = escreva, linha = 1
Token tipo = VARIAVEL, valor = x, linha = 1
Token tipo = OP_SOMA, valor = +, linha = 1
Token tipo = VARIAVEL, valor = y, linha = 1
Token tipo = OP_FINAL_LINHA_PONTO_VIRGULA, valor = ;, linha = 1
Token tipo = FMPROGRAMA, valor = fmprograma, linha = 1
\end{verbatim}

\subsection{parser.out.py}
O arquivo parser.out.py é responsável por realizar a análise e validação 
sintática de um programa, seguindo as regras de uma gramática definida. 
Ele utiliza o método de análise LALR (Look-Ahead LR) para verificar a 
conformidade do código com a gramática especificada.

\subsubsection{Gramatica}
As regras da gramática são listadas no início do código. Elas indicam 
como cada parte do programa deve ser estruturada. Por exemplo, programa 
INPROGRAMA declarações FMPROGRAMA significa que um programa começa com 
INPROGRAMA, seguido por declarações e termina com FMPROGRAMA.
Grammar

\begin{verbatim}

Rule 0     S' -> programa
Rule 1     programa -> INPROGRAMA declaracoes FMPROGRAMA
Rule 2     declaracoes -> declaracao
Rule 3     declaracoes -> declaracoes declaracao
Rule 4     declaracao -> NI VARIAVEL OP_ATRIB_IGUAL 
expressao OP_FINAL_LINHA_PONTO_VIRGULA
Rule 5     declaracao -> VARIAVEL OP_ATRIB_IGUAL 
expressao OP_FINAL_LINHA_PONTO_VIRGULA
Rule 6     declaracao -> ESCREVA expressao 
OP_FINAL_LINHA_PONTO_VIRGULA
Rule 7     declaracao -> LEIA VARIAVEL 
OP_FINAL_LINHA_PONTO_VIRGULA
Rule 8     declaracao -> PARA 
OP_PAR_ESQUERDO VARIAVEL IN RANGE OP_PAR_ESQUERDO expressao 
OP_PAR_DIREITO OP_PAR_DIREITO 
OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA
Rule 9     declaracao -> ENQUANTO 
OP_PAR_ESQUERDO condicao OP_PAR_DIREITO 
OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA
Rule 10    expressao -> INTEIRO
Rule 11    expressao -> FLOAT
Rule 12    expressao -> VARIAVEL
Rule 13    expressao -> VARIAVEL OP_SOMA expressao
Rule 14    condicao -> expressao LESS expressao
Rule 15    condicao -> expressao GREATER expressao

\end{verbatim}



\subsubsection{Terminais}
Terminais referem-se aos símbolos de entrada em uma gramática formal. 
Eles são os elementos mais básicos que compõem uma linguagem. Durante o 
processo de análise sintática, os terminais são comparados com os 
símbolos da gramática para reconhecer padrões e estruturas na entrada 
fornecida.

\begin{verbatim}    

Terminals, with rules where they appear

ENQUANTO             : 9
ESCREVA              : 6
FLOAT                : 11
FMPROGRAMA           : 1
GREATER              : 15
IN                   : 8
INPROGRAMA           : 1
INTEIRO              : 10
LEIA                 : 7
LESS                 : 14
NI                   : 4
OP_ATRIB_IGUAL       : 4 5
OP_CHAVE_DIREITA     : 8 9
OP_CHAVE_ESQUERDA    : 8 9
OP_FINAL_LINHA_PONTO_VIRGULA : 4 5 6 7
OP_PAR_DIREITO       : 8 8 9
OP_PAR_ESQUERDO      : 8 8 9
OP_SOMA              : 13
PARA                 : 8
RANGE                : 8
VARIAVEL             : 4 5 7 8 12 13
error                : 

\end{verbatim}

\subsubsection{Não terminais}
Os "não-terminais" são símbolos na gramática formal que podem ser 
substituídos por outros símbolos, incluindo terminais e outros não-
terminais, por meio das regras de produção. Eles representam conceitos 
abstratos ou estruturas na linguagem. Durante o processo de análise 
sintática, os não-terminais são expandidos ou substituídos por meio das 
regras de produção até que apenas terminais permaneçam.

\begin{verbatim} 
Nonterminals, with rules where they appear
condicao             : 9
declaracao           : 2 3
declaracoes          : 1 3 8 9
expressao            : 4 5 6 8 13 14 14 15 15
programa             : 0

\end{verbatim}

\subsubsection{Parsing method: LALR}
O método LALR (Look-Ahead LR) é uma técnica de análise sintática eficiente e amplamente utilizada 
em compiladores e ferramentas de processamento de linguagens. Ele é capaz de lidar com gramáticas 
complexas e permite analisar uma variedade de linguagens de programação e especificações formais.

\begin{verbatim} 
state 0

    (0) S' -> . programa
    (1) programa -> . INPROGRAMA declaracoes FMPROGRAMA

    INPROGRAMA      shift and go to state 2

    programa                       shift and go to state 1
    
\end{verbatim}

\begin{verbatim} 
state 1

    (0) S' -> programa .

\end{verbatim}


\begin{verbatim}
state 2

    (1) programa -> INPROGRAMA . declaracoes FMPROGRAMA
    (2) declaracoes -> . declaracao
    (3) declaracoes -> . declaracoes declaracao
    (4) declaracao -> . NI VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA
    (5) declaracao -> . VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA
    (6) declaracao -> . ESCREVA expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA
    (7) declaracao -> . LEIA VARIAVEL 
    OP_FINAL_LINHA_PONTO_VIRGULA
    (8) declaracao -> . PARA OP_PAR_ESQUERDO VARIAVEL IN RANGE OP_PAR_ESQUERDO 
    
    expressao OP_PAR_DIREITO OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA
    (9) declaracao -> . ENQUANTO OP_PAR_ESQUERDO condicao 
    
    OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA

    NI              shift and go to state 5
    VARIAVEL        shift and go to state 6
    ESCREVA         shift and go to state 7
    LEIA            shift and go to state 8
    PARA            shift and go to state 9
    ENQUANTO        shift and go to state 10

    declaracoes                    shift and go to state 3
    declaracao                     shift and go to state 4

\end{verbatim}


\begin{verbatim}
state 3

    (1) programa -> INPROGRAMA declaracoes . FMPROGRAMA
    (3) declaracoes -> declaracoes . declaracao
    (4) declaracao -> . NI VARIAVEL 
    OP_ATRIB_IGUAL expressao OP_FINAL_LINHA_PONTO_VIRGULA
    (5) declaracao -> . VARIAVEL 
    OP_ATRIB_IGUAL expressao OP_FINAL_LINHA_PONTO_VIRGULA
    (6) declaracao -> . ESCREVA expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA
    (7) declaracao -> . LEIA VARIAVEL 
    OP_FINAL_LINHA_PONTO_VIRGULA
    (8) declaracao -> . PARA OP_PAR_ESQUERDO VARIAVEL IN RANGE OP_PAR_ESQUERDO 
    expressao OP_PAR_DIREITO OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes 
    OP_CHAVE_DIREITA
    (9) declaracao -> . ENQUANTO OP_PAR_ESQUERDO condicao 
    OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA

    FMPROGRAMA      shift and go to state 11
    NI              shift and go to state 5
    VARIAVEL        shift and go to state 6
    ESCREVA         shift and go to state 7
    LEIA            shift and go to state 8
    PARA            shift and go to state 9
    ENQUANTO        shift and go to state 10

    declaracao                     shift and go to state 12

\end{verbatim}

\begin{verbatim}
state 4

    (2) declaracoes -> declaracao .

    FMPROGRAMA      reduce using rule 2 (declaracoes -> declaracao .)
    NI              reduce using rule 2 (declaracoes -> declaracao .)
    VARIAVEL        reduce using rule 2 (declaracoes -> declaracao .)
    ESCREVA         reduce using rule 2 (declaracoes -> declaracao .)
    LEIA            reduce using rule 2 (declaracoes -> declaracao .)
    PARA            reduce using rule 2 (declaracoes -> declaracao .)
    ENQUANTO        reduce using rule 2 (declaracoes -> declaracao .)
    OP_CHAVE_DIREITA reduce using rule 2 (declaracoes -> declaracao .)

\end{verbatim}

\begin{verbatim}
state 5

    (4) declaracao -> NI . VARIAVEL 
    OP_ATRIB_IGUAL expressao OP_FINAL_LINHA_PONTO_VIRGULA

    VARIAVEL        shift and go to state 13
    
\end{verbatim}

\begin{verbatim}
state 6

    (5) declaracao -> VARIAVEL . 
    OP_ATRIB_IGUAL expressao OP_FINAL_LINHA_PONTO_VIRGULA

    OP_ATRIB_IGUAL  shift and go to state 14
    
\end{verbatim}

\begin{verbatim}
state 7

    (6) declaracao -> ESCREVA . expressao OP_FINAL_LINHA_PONTO_VIRGULA
    (10) expressao -> . INTEIRO
    (11) expressao -> . FLOAT
    (12) expressao -> . VARIAVEL
    (13) expressao -> . VARIAVEL OP_SOMA expressao

    INTEIRO         shift and go to state 16
    FLOAT           shift and go to state 17
    VARIAVEL        shift and go to state 18

    expressao                      shift and go to state 15

\end{verbatim}

\begin{verbatim}
state 8

    (7) declaracao -> LEIA . VARIAVEL OP_FINAL_LINHA_PONTO_VIRGULA

    VARIAVEL        shift and go to state 19
\end{verbatim}

\begin{verbatim}
state 9

    (8) declaracao -> PARA . OP_PAR_ESQUERDO VARIAVEL IN RANGE 
    OP_PAR_ESQUERDO 
    expressao OP_PAR_DIREITO OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA

    OP_PAR_ESQUERDO shift and go to state 20
\end{verbatim}

\begin{verbatim}
state 10

    (9) declaracao -> ENQUANTO . 
    OP_PAR_ESQUERDO condicao 
    OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA

    OP_PAR_ESQUERDO shift and go to state 21
\end{verbatim}

\begin{verbatim}
state 11

    (1) programa -> INPROGRAMA declaracoes FMPROGRAMA .

    $end    reduce using rule 1 (programa -> INPROGRAMA declaracoes 
    FMPROGRAMA .)
\end{verbatim}

\begin{verbatim}
state 12

    (3) declaracoes -> declaracoes declaracao .

    FMPROGRAMA      reduce using rule 3 (declaracoes -> declaracoes 
    declaracao .)
    NI              reduce using rule 3 (declaracoes -> declaracoes 
    declaracao .)
    VARIAVEL        reduce using rule 3 (declaracoes -> declaracoes 
    declaracao .)
    ESCREVA         reduce using rule 3 (declaracoes -> declaracoes 
    declaracao .)
    LEIA            reduce using rule 3 (declaracoes -> declaracoes 
    declaracao .)
    PARA            reduce using rule 3 (declaracoes -> declaracoes 
    declaracao .)
    ENQUANTO        reduce using rule 3 (declaracoes -> declaracoes 
    declaracao .)
    OP_CHAVE_DIREITA reduce using rule 3 (declaracoes -> declaracoes 
    declaracao .)

\end{verbatim}

\begin{verbatim}
state 13

    (4) declaracao -> NI VARIAVEL . 
    OP_ATRIB_IGUAL expressao OP_FINAL_LINHA_PONTO_VIRGULA

    OP_ATRIB_IGUAL  shift and go to state 22

\end{verbatim}

\begin{verbatim}
state 14

    (5) declaracao -> VARIAVEL OP_ATRIB_IGUAL . 
    expressao OP_FINAL_LINHA_PONTO_VIRGULA
    (10) expressao -> . INTEIRO
    (11) expressao -> . FLOAT
    (12) expressao -> . VARIAVEL
    (13) expressao -> . VARIAVEL OP_SOMA expressao

    INTEIRO         shift and go to state 16
    FLOAT           shift and go to state 17
    VARIAVEL        shift and go to state 18

    expressao                      shift and go to state 23

\end{verbatim}

\begin{verbatim}
state 15

    (6) declaracao -> ESCREVA expressao . 
    
    OP_FINAL_LINHA_PONTO_VIRGULA

    OP_FINAL_LINHA_PONTO_VIRGULA shift and go to state 24

\end{verbatim}

\begin{verbatim}
state 16

    (10) expressao -> INTEIRO .

    OP_FINAL_LINHA_PONTO_VIRGULA reduce using rule 10 (expressao -> 
    INTEIRO .)
    LESS            reduce using rule 10 (expressao -> INTEIRO .)
    GREATER         reduce using rule 10 (expressao -> INTEIRO .)
    OP_PAR_DIREITO  reduce using rule 10 (expressao -> INTEIRO .)

\end{verbatim}

\begin{verbatim}
state 17

    (11) expressao -> FLOAT .

    OP_FINAL_LINHA_PONTO_VIRGULA reduce using rule 11 (expressao -> FLOAT 
    .)
    LESS            reduce using rule 11 (expressao -> FLOAT .)
    GREATER         reduce using rule 11 (expressao -> FLOAT .)
    OP_PAR_DIREITO  reduce using rule 11 (expressao -> FLOAT .)

\end{verbatim}

\begin{verbatim}
state 18

    (12) expressao -> VARIAVEL .
    (13) expressao -> VARIAVEL . OP_SOMA expressao

    OP_FINAL_LINHA_PONTO_VIRGULA reduce using rule 12 (expressao -> 
    VARIAVEL .)
    LESS            reduce using rule 12 (expressao -> VARIAVEL .)
    GREATER         reduce using rule 12 (expressao -> VARIAVEL .)
    OP_PAR_DIREITO  reduce using rule 12 (expressao -> VARIAVEL .)
    OP_SOMA         shift and go to state 25

\end{verbatim}

\begin{verbatim}
state 19

    (7) declaracao -> LEIA VARIAVEL . OP_FINAL_LINHA_PONTO_VIRGULA

    OP_FINAL_LINHA_PONTO_VIRGULA shift and go to state 26

\end{verbatim}

\begin{verbatim}
state 20

    (8) declaracao -> PARA OP_PAR_ESQUERDO . VARIAVEL IN RANGE 
    OP_PAR_ESQUERDO 
    expressao OP_PAR_DIREITO OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA

    VARIAVEL        shift and go to state 27

\end{verbatim}

\begin{verbatim}
state 21

    (9) declaracao -> ENQUANTO OP_PAR_ESQUERDO . condicao OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA
    (14) condicao -> . expressao LESS expressao
    (15) condicao -> . expressao GREATER expressao
    (10) expressao -> . INTEIRO
    (11) expressao -> . FLOAT
    (12) expressao -> . VARIAVEL
    (13) expressao -> . VARIAVEL OP_SOMA expressao

    INTEIRO         shift and go to state 16
    FLOAT           shift and go to state 17
    VARIAVEL        shift and go to state 18

    condicao                       shift and go to state 28
    expressao                      shift and go to state 29

\end{verbatim}

\begin{verbatim}
state 22

    (4) declaracao -> NI VARIAVEL OP_ATRIB_IGUAL . expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA
    (10) expressao -> . INTEIRO
    (11) expressao -> . FLOAT
    (12) expressao -> . VARIAVEL
    (13) expressao -> . VARIAVEL OP_SOMA expressao

    INTEIRO         shift and go to state 16
    FLOAT           shift and go to state 17
    VARIAVEL        shift and go to state 18

    expressao                      shift and go to state 30

\end{verbatim}

\begin{verbatim}
state 23

    (5) declaracao -> VARIAVEL OP_ATRIB_IGUAL expressao . 
    OP_FINAL_LINHA_PONTO_VIRGULA

    OP_FINAL_LINHA_PONTO_VIRGULA shift and go to state 31

\end{verbatim}

\begin{verbatim}
state 24

    (6) declaracao -> ESCREVA expressao OP_FINAL_LINHA_PONTO_VIRGULA .

    FMPROGRAMA      reduce using rule 6 
    (declaracao -> ESCREVA expressao OP_FINAL_LINHA_PONTO_VIRGULA .)
    NI              reduce using rule 6 
    (declaracao -> ESCREVA expressao OP_FINAL_LINHA_PONTO_VIRGULA .)
    VARIAVEL        reduce using rule 6 
    (declaracao -> ESCREVA expressao OP_FINAL_LINHA_PONTO_VIRGULA .)
    ESCREVA         reduce using rule 6 
    (declaracao -> ESCREVA expressao OP_FINAL_LINHA_PONTO_VIRGULA .)
    LEIA            reduce using rule 6 
    (declaracao -> ESCREVA expressao OP_FINAL_LINHA_PONTO_VIRGULA .)
    PARA            reduce using rule 6 
    (declaracao -> ESCREVA expressao OP_FINAL_LINHA_PONTO_VIRGULA .)
    ENQUANTO        reduce using rule 6 
    (declaracao -> ESCREVA expressao OP_FINAL_LINHA_PONTO_VIRGULA .)
    OP_CHAVE_DIREITA reduce using rule 6 
    (declaracao -> ESCREVA expressao OP_FINAL_LINHA_PONTO_VIRGULA .)

\end{verbatim}

\begin{verbatim}
state 25

    (13) expressao -> VARIAVEL OP_SOMA . expressao
    (10) expressao -> . INTEIRO
    (11) expressao -> . FLOAT
    (12) expressao -> . VARIAVEL
    (13) expressao -> . VARIAVEL OP_SOMA expressao

    INTEIRO         shift and go to state 16
    FLOAT           shift and go to state 17
    VARIAVEL        shift and go to state 18

    expressao                      shift and go to state 32

\end{verbatim}

\begin{verbatim}
state 26

    (7) declaracao -> LEIA VARIAVEL OP_FINAL_LINHA_PONTO_VIRGULA .

    FMPROGRAMA      reduce using rule 7 
    (declaracao -> LEIA VARIAVEL OP_FINAL_LINHA_PONTO_VIRGULA .)
    NI              reduce using rule 7 
    (declaracao -> LEIA VARIAVEL OP_FINAL_LINHA_PONTO_VIRGULA .)
    VARIAVEL        reduce using rule 7 
    (declaracao -> LEIA VARIAVEL OP_FINAL_LINHA_PONTO_VIRGULA .)
    ESCREVA         reduce using rule 7 
    (declaracao -> LEIA VARIAVEL OP_FINAL_LINHA_PONTO_VIRGULA .)
    LEIA            reduce using rule 7 
    (declaracao -> LEIA VARIAVEL OP_FINAL_LINHA_PONTO_VIRGULA .)
    PARA            reduce using rule 7 
    (declaracao -> LEIA VARIAVEL OP_FINAL_LINHA_PONTO_VIRGULA .)
    ENQUANTO        reduce using rule 7 
    (declaracao -> LEIA VARIAVEL OP_FINAL_LINHA_PONTO_VIRGULA .)
    OP_CHAVE_DIREITA reduce using rule 7 
    (declaracao -> LEIA VARIAVEL OP_FINAL_LINHA_PONTO_VIRGULA .)

\end{verbatim}

\begin{verbatim}
state 27

    (8) declaracao -> PARA OP_PAR_ESQUERDO VARIAVEL . 
    IN RANGE OP_PAR_ESQUERDO expressao OP_PAR_DIREITO OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA

    IN              shift and go to state 33

\end{verbatim}

\begin{verbatim}
state 28

    (9) declaracao -> ENQUANTO OP_PAR_ESQUERDO condicao . 
    OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA

    OP_PAR_DIREITO  shift and go to state 34

\end{verbatim}

\begin{verbatim}
state 29

    (14) condicao -> expressao . LESS expressao
    (15) condicao -> expressao . GREATER expressao

    LESS            shift and go to state 35
    GREATER         shift and go to state 36

\end{verbatim}

\begin{verbatim}
state 30

    (4) declaracao -> NI VARIAVEL OP_ATRIB_IGUAL expressao . 
    OP_FINAL_LINHA_PONTO_VIRGULA

    OP_FINAL_LINHA_PONTO_VIRGULA shift and go to state 37

\end{verbatim}

\begin{verbatim}
state 31

    (5) declaracao -> VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA .

    FMPROGRAMA      reduce using rule 5 
    (declaracao -> VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA .)
    NI              reduce using rule 5 
    (declaracao -> VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA .)
    VARIAVEL        reduce using rule 5 
    (declaracao -> VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA .)
    ESCREVA         reduce using rule 5 
    (declaracao -> VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA .)
    LEIA            reduce using rule 5 
    (declaracao -> VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA .)
    PARA            reduce using rule 5 
    (declaracao -> VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA .)
    ENQUANTO        reduce using rule 5 
    (declaracao -> VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA .)
    OP_CHAVE_DIREITA reduce using rule 5 
    (declaracao -> VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA .)

\end{verbatim}

\begin{verbatim}
state 32

    (13) expressao -> VARIAVEL OP_SOMA expressao .

    OP_FINAL_LINHA_PONTO_VIRGULA reduce using rule 13 
    (expressao -> VARIAVEL OP_SOMA expressao .)
    LESS            reduce using rule 13 
    (expressao -> VARIAVEL OP_SOMA expressao .)
    GREATER         reduce using rule 13 
    (expressao -> VARIAVEL OP_SOMA expressao .)
    OP_PAR_DIREITO  reduce using rule 13 
    (expressao -> VARIAVEL OP_SOMA expressao .)

\end{verbatim}

\begin{verbatim}
state 33

    (8) declaracao -> PARA OP_PAR_ESQUERDO VARIAVEL IN . RANGE 
    OP_PAR_ESQUERDO 
    expressao OP_PAR_DIREITO OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA

    RANGE           shift and go to state 38

\end{verbatim}

\begin{verbatim}
state 34

    (9) declaracao -> ENQUANTO OP_PAR_ESQUERDO condicao 
    OP_PAR_DIREITO . OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA

    OP_CHAVE_ESQUERDA shift and go to state 39

\end{verbatim}

\begin{verbatim}
state 35

    (14) condicao -> expressao LESS . expressao
    (10) expressao -> . INTEIRO
    (11) expressao -> . FLOAT
    (12) expressao -> . VARIAVEL
    (13) expressao -> . VARIAVEL OP_SOMA expressao

    INTEIRO         shift and go to state 16
    FLOAT           shift and go to state 17
    VARIAVEL        shift and go to state 18

    expressao                      shift and go to state 40

\end{verbatim}

\begin{verbatim}
state 36

    (15) condicao -> expressao GREATER . expressao
    (10) expressao -> . INTEIRO
    (11) expressao -> . FLOAT
    (12) expressao -> . VARIAVEL
    (13) expressao -> . VARIAVEL OP_SOMA expressao

    INTEIRO         shift and go to state 16
    FLOAT           shift and go to state 17
    VARIAVEL        shift and go to state 18

    expressao                      shift and go to state 41

\end{verbatim}

\begin{verbatim}
state 37

    (4) declaracao -> NI VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA .

    FMPROGRAMA      reduce using rule 4 
    (declaracao -> NI VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA .)
    NI              reduce using rule 4 
    (declaracao -> NI VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA .)
    VARIAVEL        reduce using rule 4 
    (declaracao -> NI VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA .)
    ESCREVA         reduce using rule 4 
    (declaracao -> NI VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA .)
    LEIA            reduce using rule 4 
    (declaracao -> NI VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA .)
    PARA            reduce using rule 4 
    (declaracao -> NI VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA .)
    ENQUANTO        reduce using rule 4 
    (declaracao -> NI VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA .)
    
    OP_CHAVE_DIREITA reduce using rule 4 
    (declaracao -> NI VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA .)

\end{verbatim}

\begin{verbatim}
state 38

    (8) declaracao -> PARA OP_PAR_ESQUERDO VARIAVEL IN RANGE . 
    OP_PAR_ESQUERDO expressao OP_PAR_DIREITO OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA

    OP_PAR_ESQUERDO shift and go to state 42

\end{verbatim}

\begin{verbatim}
state 39

    (9) declaracao -> ENQUANTO OP_PAR_ESQUERDO 
    condicao OP_PAR_DIREITO OP_CHAVE_ESQUERDA . declaracoes OP_CHAVE_DIREITA
    (2) declaracoes -> . declaracao
    (3) declaracoes -> . declaracoes declaracao
    (4) declaracao -> . NI VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA
    (5) declaracao -> . VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA
    (6) declaracao -> . ESCREVA expressao OP_FINAL_LINHA_PONTO_VIRGULA
    (7) declaracao -> . LEIA VARIAVEL OP_FINAL_LINHA_PONTO_VIRGULA
    (8) declaracao -> . PARA OP_PAR_ESQUERDO VARIAVEL IN RANGE 
    OP_PAR_ESQUERDO expressao OP_PAR_DIREITO OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA
    (9) declaracao -> . ENQUANTO OP_PAR_ESQUERDO condicao 
    OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA

    NI              shift and go to state 5
    VARIAVEL        shift and go to state 6
    ESCREVA         shift and go to state 7
    LEIA            shift and go to state 8
    PARA            shift and go to state 9
    ENQUANTO        shift and go to state 10

    declaracoes                    shift and go to state 43
    declaracao                     shift and go to state 4

\end{verbatim}

\begin{verbatim}
state 40

    (14) condicao -> expressao LESS expressao .

    OP_PAR_DIREITO  reduce using rule 14 (condicao -> expressao LESS expressao .)

\end{verbatim}

\begin{verbatim}
state 41

    (15) condicao -> expressao GREATER expressao .

    OP_PAR_DIREITO  reduce using rule 15 (condicao -> expressao GREATER 
    expressao .)

\end{verbatim}

\begin{verbatim}
state 42

    (8) declaracao -> PARA OP_PAR_ESQUERDO VARIAVEL IN RANGE 
    OP_PAR_ESQUERDO . 
    expressao OP_PAR_DIREITO OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA
    (10) expressao -> . INTEIRO
    (11) expressao -> . FLOAT
    (12) expressao -> . VARIAVEL
    (13) expressao -> . VARIAVEL OP_SOMA expressao

    INTEIRO         shift and go to state 16
    FLOAT           shift and go to state 17
    VARIAVEL        shift and go to state 18

    expressao                      shift and go to state 44

\end{verbatim}

\begin{verbatim}
state 43

    (9) declaracao -> ENQUANTO OP_PAR_ESQUERDO condicao 
    OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes . OP_CHAVE_DIREITA
    (3) declaracoes -> declaracoes . declaracao
    (4) declaracao -> . NI VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA
    (5) declaracao -> . VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA
    (6) declaracao -> . ESCREVA expressao OP_FINAL_LINHA_PONTO_VIRGULA
    (7) declaracao -> . LEIA VARIAVEL OP_FINAL_LINHA_PONTO_VIRGULA
    (8) declaracao -> . PARA OP_PAR_ESQUERDO VARIAVEL IN RANGE 
    OP_PAR_ESQUERDO expressao OP_PAR_DIREITO OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA
    (9) declaracao -> . ENQUANTO OP_PAR_ESQUERDO condicao 
    OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA

    OP_CHAVE_DIREITA shift and go to state 45
    NI              shift and go to state 5
    VARIAVEL        shift and go to state 6
    ESCREVA         shift and go to state 7
    LEIA            shift and go to state 8
    PARA            shift and go to state 9
    ENQUANTO        shift and go to state 10

    declaracao                     shift and go to state 12
\end{verbatim}

\begin{verbatim}
state 44

    (8) declaracao -> PARA OP_PAR_ESQUERDO VARIAVEL IN RANGE 
    OP_PAR_ESQUERDO 
    expressao . OP_PAR_DIREITO OP_PAR_DIREITO OP_CHAVE_ESQUERDA 
    declaracoes OP_CHAVE_DIREITA

    OP_PAR_DIREITO  shift and go to state 46
\end{verbatim}

\begin{verbatim}
state 45

    (9) declaracao -> ENQUANTO OP_PAR_ESQUERDO condicao OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA .

    FMPROGRAMA      reduce using rule 9 
    (declaracao -> ENQUANTO OP_PAR_ESQUERDO condicao OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA .)
    NI              reduce using rule 9 
    (declaracao -> ENQUANTO OP_PAR_ESQUERDO condicao OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA .)
    VARIAVEL        reduce using rule 9 
    (declaracao -> ENQUANTO OP_PAR_ESQUERDO condicao OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA .)
    ESCREVA         reduce using rule 9 
    (declaracao -> ENQUANTO OP_PAR_ESQUERDO condicao OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA .)
    LEIA            reduce using rule 9 
    (declaracao -> ENQUANTO OP_PAR_ESQUERDO condicao OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA .)
    PARA            reduce using rule 9 
    (declaracao -> ENQUANTO OP_PAR_ESQUERDO condicao OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA .)
    ENQUANTO        reduce using rule 9 
    (declaracao -> ENQUANTO OP_PAR_ESQUERDO condicao OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA .)
    OP_CHAVE_DIREITA reduce using rule 9 
    (declaracao -> ENQUANTO OP_PAR_ESQUERDO condicao OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA .)
\end{verbatim}

\begin{verbatim}
state 46

    (8) declaracao -> PARA OP_PAR_ESQUERDO VARIAVEL IN RANGE 
    OP_PAR_ESQUERDO expressao 
    OP_PAR_DIREITO . OP_PAR_DIREITO OP_CHAVE_ESQUERDA 
    declaracoes OP_CHAVE_DIREITA

    OP_PAR_DIREITO  shift and go to state 47
\end{verbatim}

\begin{verbatim}
state 47

    (8) declaracao -> PARA OP_PAR_ESQUERDO VARIAVEL IN RANGE 
    OP_PAR_ESQUERDO 
    expressao OP_PAR_DIREITO OP_PAR_DIREITO . 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA

    OP_CHAVE_ESQUERDA shift and go to state 48
\end{verbatim}

\begin{verbatim}
state 48

    (8) declaracao -> PARA OP_PAR_ESQUERDO VARIAVEL IN RANGE 
    OP_PAR_ESQUERDO expressao OP_PAR_DIREITO OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA . declaracoes OP_CHAVE_DIREITA
    (2) declaracoes -> . declaracao
    (3) declaracoes -> . declaracoes declaracao
    (4) declaracao -> . NI VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA
    (5) declaracao -> . VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA
    (6) declaracao -> . ESCREVA expressao OP_FINAL_LINHA_PONTO_VIRGULA
    (7) declaracao -> . LEIA VARIAVEL OP_FINAL_LINHA_PONTO_VIRGULA
    (8) declaracao -> . PARA OP_PAR_ESQUERDO VARIAVEL IN RANGE 
    OP_PAR_ESQUERDO expressao OP_PAR_DIREITO OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA
    (9) declaracao -> . ENQUANTO OP_PAR_ESQUERDO condicao 
    OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA

    NI              shift and go to state 5
    VARIAVEL        shift and go to state 6
    ESCREVA         shift and go to state 7
    LEIA            shift and go to state 8
    PARA            shift and go to state 9
    ENQUANTO        shift and go to state 10

    declaracoes                    shift and go to state 49
    declaracao                     shift and go to state 4
\end{verbatim}    
    
\begin{verbatim}
state 49

    (8) declaracao -> PARA OP_PAR_ESQUERDO VARIAVEL IN RANGE 
    OP_PAR_ESQUERDO expressao OP_PAR_DIREITO OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes . OP_CHAVE_DIREITA
    (3) declaracoes -> declaracoes . declaracao
    (4) declaracao -> . NI VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA
    (5) declaracao -> . VARIAVEL OP_ATRIB_IGUAL expressao 
    OP_FINAL_LINHA_PONTO_VIRGULA
    (6) declaracao -> . ESCREVA expressao OP_FINAL_LINHA_PONTO_VIRGULA
    (7) declaracao -> . LEIA VARIAVEL OP_FINAL_LINHA_PONTO_VIRGULA
    (8) declaracao -> . PARA OP_PAR_ESQUERDO VARIAVEL IN RANGE 
    OP_PAR_ESQUERDO expressao OP_PAR_DIREITO OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA
    (9) declaracao -> . ENQUANTO OP_PAR_ESQUERDO condicao 
    OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA

    OP_CHAVE_DIREITA shift and go to state 50
    NI              shift and go to state 5
    VARIAVEL        shift and go to state 6
    ESCREVA         shift and go to state 7
    LEIA            shift and go to state 8
    PARA            shift and go to state 9
    ENQUANTO        shift and go to state 10

    declaracao                     shift and go to state 12
\end{verbatim}    
    
\begin{verbatim}
state 50

    (8) declaracao -> PARA OP_PAR_ESQUERDO VARIAVEL IN RANGE 
    OP_PAR_ESQUERDO expressao OP_PAR_DIREITO OP_PAR_DIREITO 
    OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA .

    FMPROGRAMA      reduce using rule 8 (declaracao -> PARA 
    OP_PAR_ESQUERDO VARIAVEL IN RANGE OP_PAR_ESQUERDO expressao 
    OP_PAR_DIREITO OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes 
    OP_CHAVE_DIREITA .)
    NI              reduce using rule 8 (declaracao -> PARA 
    OP_PAR_ESQUERDO VARIAVEL IN RANGE OP_PAR_ESQUERDO expressao 
    OP_PAR_DIREITO OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes 
    OP_CHAVE_DIREITA .)
    VARIAVEL        reduce using rule 8 (declaracao -> PARA 
    OP_PAR_ESQUERDO VARIAVEL IN RANGE OP_PAR_ESQUERDO expressao 
    OP_PAR_DIREITO OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes 
    OP_CHAVE_DIREITA .)
    ESCREVA         reduce using rule 8 (declaracao -> PARA 
    OP_PAR_ESQUERDO VARIAVEL IN RANGE OP_PAR_ESQUERDO expressao 
    OP_PAR_DIREITO OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes 
    OP_CHAVE_DIREITA .)
    LEIA            reduce using rule 8 (declaracao -> PARA 
    OP_PAR_ESQUERDO VARIAVEL IN RANGE OP_PAR_ESQUERDO expressao 
    OP_PAR_DIREITO OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes 
    OP_CHAVE_DIREITA .)
    PARA            reduce using rule 8 (declaracao -> PARA 
    OP_PAR_ESQUERDO VARIAVEL IN RANGE OP_PAR_ESQUERDO expressao 
    OP_PAR_DIREITO OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes 
    OP_CHAVE_DIREITA .)
    ENQUANTO        reduce using rule 8 (declaracao -> PARA 
    OP_PAR_ESQUERDO VARIAVEL IN RANGE OP_PAR_ESQUERDO expressao 
    OP_PAR_DIREITO OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes 
    OP_CHAVE_DIREITA .)
    OP_CHAVE_DIREITA reduce using rule 8 (declaracao -> PARA 
    OP_PAR_ESQUERDO VARIAVEL IN RANGE OP_PAR_ESQUERDO expressao 
    OP_PAR_DIREITO OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes 
    OP_CHAVE_DIREITA .)

\end{verbatim}

\vspace{15 cm}
\subsection{Parser.tab.py}
\subsubsection{lr\_method: Método de análise sintática}
O método de análise sintática (parser method) define como a gramática 
será processada durante a análise do código fonte. Neste caso, o método 
utilizado é o LALR (Look-Ahead Left-to-Right), que é uma técnica 
eficiente para analisar gramáticas livres de contexto. Ele trabalha 
percorrendo a entrada da esquerda para a direita, usando um mecanismo de 
antecipação (look-ahead) para decidir quais ações tomar durante o 
processo de análise.


\_lr\_method: Define o método usado para analisar a gramática. Neste 
caso, é utilizado o método LALR (Look-Ahead Left-to-Right).
\begin{Verbatim}
_lr_method = 'LALR'
\end{Verbatim}

\_lr\_signature: Contém uma assinatura da gramática. Esta é uma 
representação compacta da gramática definida nas regras abaixo.
\begin{Verbatim}
_lr_signature = 'ENQUANTO ESCREVA FLOAT FMPROGRAMA GREATER IN INPROGRAMA 
INTEIRO LEIA LESS NI OP_ATRIB_IGUAL OP_CHAVE_DIREITA OP_CHAVE_ESQUERDA 
OP_FINAL_LINHA_PONTO_VIRGULA OP_PAR_DIREITO OP_PAR_ESQUERDO OP_SOMA PARA 
RANGE VARIAVEL\n    programa : INPROGRAMA declaracoes FMPROGRAMA\n    \n 
declaracoes : declaracao\n    \n    declaracoes : declaracoes 
declaracao\n    \n    declaracao : NI VARIAVEL OP_ATRIB_IGUAL expressao 
OP_FINAL_LINHA_PONTO_VIRGULA\n    \n    declaracao : VARIAVEL 
OP_ATRIB_IGUAL expressao OP_FINAL_LINHA_PONTO_VIRGULA\n    \n    
declaracao : ESCREVA expressao OP_FINAL_LINHA_PONTO_VIRGULA\n    \n    
declaracao : LEIA VARIAVEL OP_FINAL_LINHA_PONTO_VIRGULA\n    \n    
declaracao : PARA OP_PAR_ESQUERDO VARIAVEL IN RANGE OP_PAR_ESQUERDO 
expressao OP_PAR_DIREITO OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes 
OP_CHAVE_DIREITA\n    \n    declaracao : ENQUANTO OP_PAR_ESQUERDO 
condicao OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes OP_CHAVE_DIREITA\n 
\n    expressao : INTEIRO\n              | FLOAT\n              | 
VARIAVEL\n              | VARIAVEL OP_SOMA expressao\n    \n    condicao 
: expressao LESS expressao\n             | expressao GREATER expressao\n 
'
\end{Verbatim}

\_lr\_action\_items: Mapeia os estados e os símbolos de entrada para as 
ações a serem tomadas pelo analisador. As chaves são os estados do 
analisador e os valores são pares de listas que mapeiam os símbolos de 
entrada para as ações. Por exemplo, quando o estado 2 (representando o 
símbolo "INPROGRAMA") é alcançado, a ação a ser tomada é reduzir para a 
produção 2.

\begin{Verbatim}
_lr_action_items = {'INPROGRAMA':([0,],[2,]),end':([1,11,],
[0,-1,]),'NI':([2,3,4,12,24,26,31,37,39,43,45,48,49,50,],
[5,5,-2,-3,-6,-7,-5,-4,5,5,-9,5,5,-8,]),'VARIAVEL':
([2,3,4,5,7,8,12,14,20,21,22,24,25,26,31,35,36,37,39,42,43,45,48,49,50,],
[6,6,-2,13,18,19,-3,18,27,18,18,-6,18,-7,-5,18,18,-4,6,18,6,-9,6,6,-8,]),
'ESCREVA':([2,3,4,12,24,26,31,37,39,43,45,48,49,50,],
[7,7,-2,-3,-6,-7,-5,-4,7,7,-9,7,7,-8,]),'LEIA':
([2,3,4,12,24,26,31,37,39,43,45,48,49,50,],
[8,8,-2,-3,-6,-7,-5,-4,8,8,-9,8,8,-8,]),'PARA':
([2,3,4,12,24,26,31,37,39,43,45,48,49,50,],
[9,9,-2,-3,-6,-7,-5,-4,9,9,-9,9,9,-8,]),'ENQUANTO':
([2,3,4,12,24,26,31,37,39,43,45,48,49,50,],
[10,10,-2,-3,-6,-7,-5,-4,10,10,-9,10,10,-8,]),'FMPROGRAMA':
([3,4,12,24,26,31,37,45,50,],
[11,-2,-3,-6,-7,-5,-4,-9,-8,]),'OP_CHAVE_DIREITA':
([4,12,24,26,31,37,43,45,49,50,],
[-2,-3,-6,-7,-5,-4,45,-9,50,-8,]),'OP_ATRIB_IGUAL':([6,13,],
[14,22,]),'INTEIRO':([7,14,21,22,25,35,36,42,],
[16,16,16,16,16,16,16,16,]),'FLOAT':([7,14,21,22,25,35,36,42,],
[17,17,17,17,17,17,17,17,]),'OP_PAR_ESQUERDO':([9,10,38,],
[20,21,42,]),'OP_FINAL_LINHA_PONTO_VIRGULA':([15,16,17,18,19,23,30,32,],
[24,-10,-11,-12,26,31,37,-13,]),'LESS':([16,17,18,29,32,],
[-10,-11,-12,35,-13,]),'GREATER':([16,17,18,29,32,],
[-10,-11,-12,36,-13,]),'OP_PAR_DIREITO':([16,17,18,28,32,40,41,44,46,],
[-10,-11,-12,34,-13,-14,-15,46,47,]),'OP_SOMA':([18,],[25,]),'IN':([27,],
[33,]),'RANGE':([33,],[38,]),'OP_CHAVE_ESQUERDA':([34,47,],[39,48,]),}

\end{Verbatim}

\_lr\_goto\_items: Mapeia os estados e os símbolos não-terminais (isto 
é, símbolos que podem ser expandidos em outras regras) para os próximos 
estados a serem alcançados. Por exemplo, quando o estado 21 é alcançado, 
o próximo símbolo não-terminal é uma expressão.
\begin{Verbatim}
\_lr\_goto\_items = {'programa':([0,],[1,]),'declaracoes':([2,39,48,],
[3,43,49,]),'declaracao':([2,3,39,43,48,49,],
[4,12,4,12,4,12,]),'expressao':([7,14,21,22,25,35,36,42,],
[15,23,29,30,32,40,41,44,]),'condicao':([21,],[28,]),}
\end{Verbatim}

\_lr\_productions: Lista as produções da gramática, ou seja, as regras 
que definem como os símbolos podem ser expandidos em outros símbolos. 
Cada produção consiste em um símbolo não-terminal seguido por uma 
sequência de símbolos terminais e/ou não-terminais.
\begin{Verbatim}
_lr_productions = [
  ("S' -> programa","S'",1,None,None,None),
  ('programa -> INPROGRAMA declaracoes 
  FMPROGRAMA','programa',3,'p_programa','compilador_A3_v2.py',80),
  ('declaracoes -> 
  declaracao','declaracoes',1,'p_declaracoes_single','compilador_A3_v2.py
  ',86),
  ('declaracoes -> declaracoes 
  declaracao','declaracoes',2,'p_declaracoes_mult','compilador_A3_v2.py',
  92),
  ('declaracao -> NI VARIAVEL OP_ATRIB_IGUAL expressao 
  OP_FINAL_LINHA_PONTO_VIRGULA','declaracao',5,'p_declaracao_ni_atribuica
  o','compilador_A3_v2.py',98),
  ('declaracao -> VARIAVEL OP_ATRIB_IGUAL expressao 
  OP_FINAL_LINHA_PONTO_VIRGULA','declaracao',4,'p_declaracao_atribuicao',
  'compilador_A3_v2.py',112),
  ('declaracao -> ESCREVA expressao 
  OP_FINAL_LINHA_PONTO_VIRGULA','declaracao',3,'p_declaracao_escreva','co
  mpilador_A3_v2.py',125),
  ('declaracao -> LEIA VARIAVEL 
  OP_FINAL_LINHA_PONTO_VIRGULA','declaracao',3,'p_declaracao_leia','compi
  lador_A3_v2.py',131),
  ('declaracao -> PARA OP_PAR_ESQUERDO VARIAVEL IN RANGE OP_PAR_ESQUERDO 
  expressao OP_PAR_DIREITO OP_PAR_DIREITO OP_CHAVE_ESQUERDA declaracoes 
  OP_CHAVE_DIREITA','declaracao',12,'p_declaracao_para','compilador_A3_v2
  .py',140),
  ('declaracao -> ENQUANTO OP_PAR_ESQUERDO condicao OP_PAR_DIREITO 
  OP_CHAVE_ESQUERDA declaracoes 
  OP_CHAVE_DIREITA','declaracao',7,'p_declaracao_enquanto','compilador_A3
  _v2.py',148),
  ('expressao -> 
  INTEIRO','expressao',1,'p_expressao','compilador_A3_v2.py',154),
  ('expressao -> 
  FLOAT','expressao',1,'p_expressao','compilador_A3_v2.py',155),
  ('expressao -> 
  VARIAVEL','expressao',1,'p_expressao','compilador_A3_v2.py',156),
  ('expressao -> VARIAVEL OP_SOMA 
  expressao','expressao',3,'p_expressao','compilador_A3_v2.py',157),
  ('condicao -> expressao LESS 
  expressao','condicao',3,'p_condicao','compilador_A3_v2.py',166),
  ('condicao -> expressao GREATER 
  expressao','condicao',3,'p_condicao','compilador_A3_v2.py',167),
]
\end{Verbatim}

\subsection{codigo\_output.py}

Arquivo criado para monitorar a saída dos tokens e suas definições que 
foram geradas após a compilação do arquivo codigo\_Input.txt


\begin{Verbatim}

value = 10
x = float(input('Digite um numero : '))
y = float(input('Digite um numero : '))
for i in range(value):
    print(i)
while x < 20:
    x = x + 1.5
    print(x)
print(x + y)

\end{Verbatim}

Este código em Python demonstra algumas estruturas de controle comuns em 
linguagens de programação. Primeiro, ele define duas variáveis x e y, 
atribuindo a elas os valores convertidos para ponto flutuante inseridos 
pelo usuário via entrada (input). Em seguida, entra em um loop for, 
iterando sobre os valores no intervalo de 0 a 9 (pois value é definido 
como 10). Dentro deste loop, cada valor de i é impresso.
Após isso, há um loop while que continua enquanto o valor de x for menor 
que 20. Dentro deste loop, x é incrementado em 1.5 a cada iteração e o 
novo valor de x é impresso.

Por fim, o código imprime a soma de x e y.

\section{Equivalencia entre codigo Input e codigo output}
O codigo input : 
\begin{verbatim}
inprograma
    ni value = 10;
    leia x;
    leia y;
    para (i in range(value)) {
        escreva i;
    }
    enquanto (x < 20) {
        x = x + 1.5;
        escreva x;
    }
    escreva x + y;
fmprograma

\end{verbatim}
o codigo output : 
\begin{verbatim}
    
value = 10
x = float(input('Digite um numero : '))
y = float(input('Digite um numero : '))
for i in range(value):
    print(i)
while x < 20:
    x = x + 1.5
    print(x)
print(x + y)

\end{verbatim}

\newpage
\section{Conclusão}

Este documento abrange integralmente o processo de desenvolvimento de um compilador, desde a concepção até a implementação final, utilizando uma linguagem especifica, projetada para a compilação. Todos os passos, foram meticulosamente planejados e executados, usando a poderosa combinação da biblioteca PLY e Python.\\

Durante o desenvolvimento, cada aspecto crítico e cada bloco de código nos arquivos gerados após a execução do compilador, foram cuidadosamente comentados. Esse processo, não apenas facilitou a compreensão do funcionamento interno do compilador, mas também permitiu uma análise aprofundada das etapas de análise léxica, análise sintática, analise semântica, geração de código e otimização.\\

Além disso, enfatizou-se a importância da modularidade e da clareza na estruturação do código-fonte do compilador. Cada componente, foi projetado para ser coeso e reutilizável, seguindo as melhores práticas de engenharia de software.\\

Ao final, o compilador demonstrou não apenas a capacidade de traduzir eficientemente programas escritos na linguagem de origem para código executável em Python, mas, também serviu como um estudo de caso valioso para entender os princípios fundamentais por trás da construção de compiladores modernos.\\

Este trabalho, não só expandiu o conhecimento teórico e prático sobre compilação e interpretação de linguagens de programação, mas também estabeleceu uma base sólida para explorar futuras melhorias e extensões no compilador, preparando para enfrentar desafios mais complexos e inovadores no campo da computação.\\

Em suma, o processo de criação deste compilador não apenas consolidou o entendimento acadêmico, mas também reforçou a habilidade de transformar conceitos abstratos em soluções concretas e funcionais, promovendo assim um ambiente de aprendizado contínuo e crescimento profissional.



\section{Referências Bibliográficas}

\begin{thebibliography}{10}
\bibitem{BibliotecaPly}

Beazley, D. M. (2020). \textit{PLY (Python Lex-Yacc) Documentation}. Acessado a primeira vez em 30/05/2024  \url{http://www.dabeaz.com/ply/}

\bibitem{github2023ply}
Repositorio do Github do criador. "PLY Compiler Example." Acessado a primeira vez em 30/05/2024 \url{https://github.com/dabeaz/ply} 

\bibitem{Lex&Yacc}
Levine, John R., Tony Mason, and Doug Brown.
\textit{Lex \& Yacc}.
2nd ed., O'Reilly Media, 1992.
\url{https://d1.amobbs.com/bbs_upload782111/files_33/ourdev_584393GCYRF3.pdf}

\bibitem{AcademicocompiladorBR2014}
AEDB. (2014). "Desenvolvimento do Compilador da Linguagem Basico." In \textit{Anais do Simpósio de Excelência em Gestão e Tecnologia (SEGeT)}.Retirado do site \url{https://www.aedb.br/seget/arquivos/artigos14/11720295.pdf}

\end{thebibliography}





\end{document}